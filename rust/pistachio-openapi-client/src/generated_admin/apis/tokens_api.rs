/*
 * Pistachio Admin API
 *
 * Administrative API for managing Pistachio projects and resources. Requires service account authentication.
 *
 * The version of the OpenAPI document: 0.1.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::generated_admin::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`create_custom_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCustomTokenError {
    Status400(models::ListTenants400Response),
    Status401(models::ListTenants400Response),
    Status403(models::ListTenants400Response),
    Status404(models::ListTenants400Response),
    Status500(models::ListTenants400Response),
    Status503(models::ListTenants400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_session_cookie`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSessionCookieError {
    Status400(models::ListTenants400Response),
    Status401(models::ListTenants400Response),
    Status403(models::ListTenants400Response),
    Status404(models::ListTenants400Response),
    Status500(models::ListTenants400Response),
    Status503(models::ListTenants400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`verify_id_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VerifyIdTokenError {
    Status400(models::ListTenants400Response),
    Status401(models::ListTenants400Response),
    Status403(models::ListTenants400Response),
    Status404(models::ListTenants400Response),
    Status500(models::ListTenants400Response),
    Status503(models::ListTenants400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`verify_session_cookie`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VerifySessionCookieError {
    Status400(models::ListTenants400Response),
    Status401(models::ListTenants400Response),
    Status403(models::ListTenants400Response),
    Status404(models::ListTenants400Response),
    Status500(models::ListTenants400Response),
    Status503(models::ListTenants400Response),
    UnknownValue(serde_json::Value),
}

/// Creates a custom token for server-side user authentication. Custom tokens allow your server to authenticate users when you manage your own user database or integrate with external identity providers.  The custom token can be exchanged for an ID token using the public API's token exchange endpoint.
pub async fn create_custom_token(
    configuration: &configuration::Configuration,
    project_id: &str,
    create_custom_token_request: models::CreateCustomTokenRequest,
) -> Result<models::CreateCustomToken200Response, Error<CreateCustomTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_body_create_custom_token_request = create_custom_token_request;

    let uri_str = format!(
        "{}/admin/v1/projects/{projectId}/customTokens",
        configuration.base_path,
        projectId = crate::generated_admin::apis::urlencode(p_path_project_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("key", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_create_custom_token_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::CreateCustomToken200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::CreateCustomToken200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateCustomTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates a long-lived session cookie from an ID token. Session cookies are designed for traditional web applications that use HTTP cookies for authentication.  The session cookie should be set as an HTTP-only, secure cookie to prevent XSS attacks.
pub async fn create_session_cookie(
    configuration: &configuration::Configuration,
    project_id: &str,
    create_session_cookie_request: models::CreateSessionCookieRequest,
) -> Result<models::CreateSessionCookie200Response, Error<CreateSessionCookieError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_body_create_session_cookie_request = create_session_cookie_request;

    let uri_str = format!(
        "{}/admin/v1/projects/{projectId}/sessionCookies",
        configuration.base_path,
        projectId = crate::generated_admin::apis::urlencode(p_path_project_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("key", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_create_session_cookie_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::CreateSessionCookie200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::CreateSessionCookie200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSessionCookieError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Verifies an ID token and returns the decoded claims. Use this to validate tokens in your server-side code.  The checkRevoked parameter adds an additional backend check to verify the user's session has not been revoked. This increases latency but provides stronger security guarantees.
pub async fn verify_id_token(
    configuration: &configuration::Configuration,
    project_id: &str,
    verify_id_token_request: models::VerifyIdTokenRequest,
) -> Result<models::VerifyIdToken200Response, Error<VerifyIdTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_body_verify_id_token_request = verify_id_token_request;

    let uri_str = format!(
        "{}/admin/v1/projects/{projectId}/idTokens:verify",
        configuration.base_path,
        projectId = crate::generated_admin::apis::urlencode(p_path_project_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("key", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_verify_id_token_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::VerifyIdToken200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::VerifyIdToken200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<VerifyIdTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Verifies a session cookie and returns the decoded claims. Use this in your server-side code to validate session cookies.  The checkRevoked parameter adds an additional backend check to verify the user's session has not been revoked. This increases latency but provides stronger security guarantees.
pub async fn verify_session_cookie(
    configuration: &configuration::Configuration,
    project_id: &str,
    verify_session_cookie_request: models::VerifySessionCookieRequest,
) -> Result<models::VerifySessionCookie200Response, Error<VerifySessionCookieError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_body_verify_session_cookie_request = verify_session_cookie_request;

    let uri_str = format!(
        "{}/admin/v1/projects/{projectId}/sessionCookies:verify",
        configuration.base_path,
        projectId = crate::generated_admin::apis::urlencode(p_path_project_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("key", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_verify_session_cookie_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::VerifySessionCookie200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::VerifySessionCookie200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<VerifySessionCookieError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
