/*
 * Pistachio Admin API
 *
 * Administrative API for managing Pistachio projects and resources. Requires service account authentication.
 *
 * The version of the OpenAPI document: 0.1.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::generated_admin::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`create_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAppError {
    Status400(models::ListApps400Response),
    Status401(models::ListApps400Response),
    Status403(models::ListApps400Response),
    Status404(models::ListApps400Response),
    Status409(models::ListApps400Response),
    Status500(models::ListApps400Response),
    Status503(models::ListApps400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAppError {
    Status400(models::ListApps400Response),
    Status401(models::ListApps400Response),
    Status403(models::ListApps400Response),
    Status404(models::ListApps400Response),
    Status500(models::ListApps400Response),
    Status503(models::ListApps400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAppError {
    Status400(models::ListApps400Response),
    Status401(models::ListApps400Response),
    Status403(models::ListApps400Response),
    Status404(models::ListApps400Response),
    Status500(models::ListApps400Response),
    Status503(models::ListApps400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_app_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAppConfigError {
    Status400(models::ListApps400Response),
    Status401(models::ListApps400Response),
    Status403(models::ListApps400Response),
    Status404(models::ListApps400Response),
    Status500(models::ListApps400Response),
    Status503(models::ListApps400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_apps`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAppsError {
    Status400(models::ListApps400Response),
    Status401(models::ListApps400Response),
    Status403(models::ListApps400Response),
    Status404(models::ListApps400Response),
    Status500(models::ListApps400Response),
    Status503(models::ListApps400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_apps`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchAppsError {
    Status400(models::ListApps400Response),
    Status401(models::ListApps400Response),
    Status403(models::ListApps400Response),
    Status404(models::ListApps400Response),
    Status500(models::ListApps400Response),
    Status503(models::ListApps400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_apps_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchAppsPostError {
    Status400(models::ListApps400Response),
    Status401(models::ListApps400Response),
    Status403(models::ListApps400Response),
    Status404(models::ListApps400Response),
    Status500(models::ListApps400Response),
    Status503(models::ListApps400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`undelete_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UndeleteAppError {
    Status400(models::ListApps400Response),
    Status401(models::ListApps400Response),
    Status403(models::ListApps400Response),
    Status404(models::ListApps400Response),
    Status409(models::ListApps400Response),
    Status500(models::ListApps400Response),
    Status503(models::ListApps400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAppError {
    Status400(models::ListApps400Response),
    Status401(models::ListApps400Response),
    Status403(models::ListApps400Response),
    Status404(models::ListApps400Response),
    Status500(models::ListApps400Response),
    Status503(models::ListApps400Response),
    UnknownValue(serde_json::Value),
}

/// Registers a new app within a project. API keys are auto-generated for each app. Platform-specific configuration must match the specified platform.
pub async fn create_app(
    configuration: &configuration::Configuration,
    project_id: &str,
    create_app_request: models::CreateAppRequest,
) -> Result<models::CreateApp200Response, Error<CreateAppError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_body_create_app_request = create_app_request;

    let uri_str = format!(
        "{}/admin/v1/projects/{projectId}/apps",
        configuration.base_path,
        projectId = crate::generated_admin::apis::urlencode(p_path_project_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("key", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_create_app_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::CreateApp200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::CreateApp200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAppError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Soft-deletes an app. The app enters DELETED state and will be permanently removed after 30 days. During this period, the app can be restored using the undelete operation.
pub async fn delete_app(
    configuration: &configuration::Configuration,
    project_id: &str,
    app_id: &str,
) -> Result<models::DeleteApp200Response, Error<DeleteAppError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_path_app_id = app_id;

    let uri_str = format!(
        "{}/admin/v1/projects/{projectId}/apps/{appId}",
        configuration.base_path,
        projectId = crate::generated_admin::apis::urlencode(p_path_project_id),
        appId = crate::generated_admin::apis::urlencode(p_path_app_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("key", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::DeleteApp200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::DeleteApp200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteAppError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves an app by its ID. Returns the app details including its platform configuration.
pub async fn get_app(
    configuration: &configuration::Configuration,
    project_id: &str,
    app_id: &str,
) -> Result<models::GetApp200Response, Error<GetAppError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_path_app_id = app_id;

    let uri_str = format!(
        "{}/admin/v1/projects/{projectId}/apps/{appId}",
        configuration.base_path,
        projectId = crate::generated_admin::apis::urlencode(p_path_project_id),
        appId = crate::generated_admin::apis::urlencode(p_path_app_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("key", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::GetApp200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GetApp200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAppError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves the SDK configuration file for an app. Returns platform-specific configuration files: - iOS: GoogleService-Info.plist (XML plist format) - Android: google-services.json (JSON format) - macOS/Windows/Linux: pistachio-config.json (JSON format) - Web: JavaScript config object (JSON format)
pub async fn get_app_config(
    configuration: &configuration::Configuration,
    project_id: &str,
    app_id: &str,
) -> Result<models::GetAppConfig200Response, Error<GetAppConfigError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_path_app_id = app_id;

    let uri_str = format!(
        "{}/admin/v1/projects/{projectId}/apps/{appId}/config",
        configuration.base_path,
        projectId = crate::generated_admin::apis::urlencode(p_path_project_id),
        appId = crate::generated_admin::apis::urlencode(p_path_app_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("key", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::GetAppConfig200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GetAppConfig200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAppConfigError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Lists all apps within a project. Results are paginated with cursor-based pagination.
pub async fn list_apps(
    configuration: &configuration::Configuration,
    project_id: &str,
    page_size: Option<i32>,
    cursor: Option<&str>,
    sort: Option<&str>,
    show_deleted: Option<bool>,
) -> Result<models::ListApps200Response, Error<ListAppsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_page_size = page_size;
    let p_query_cursor = cursor;
    let p_query_sort = sort;
    let p_query_show_deleted = show_deleted;

    let uri_str = format!(
        "{}/admin/v1/projects/{projectId}/apps",
        configuration.base_path,
        projectId = crate::generated_admin::apis::urlencode(p_path_project_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_deleted {
        req_builder = req_builder.query(&[("showDeleted", &param_value.to_string())]);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("key", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ListApps200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ListApps200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListAppsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Searches for apps within a project using full-text search.  Searchable fields: - app_id: The unique app identifier - display_name: Human-readable display name - platform: Target platform (IOS, ANDROID, MACOS, WINDOWS, LINUX, WEB) - state: App state (ACTIVE, DELETED) - created_at: Timestamp when created - updated_at: Timestamp when last updated  Example queries: - \"my_app\" - Search all fields - \"display_name:Production*\" - Apps with display name starting with \"Production\" - \"platform:IOS\" - iOS apps only - \"platform:IOS AND state:ACTIVE\" - Active iOS apps  For complex queries that exceed URL length limits, use POST instead.
pub async fn search_apps(
    configuration: &configuration::Configuration,
    project_id: &str,
    query: Option<&str>,
    page_size: Option<i32>,
    cursor: Option<&str>,
    sort: Option<&str>,
) -> Result<models::SearchApps200Response, Error<SearchAppsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_query = query;
    let p_query_page_size = page_size;
    let p_query_cursor = cursor;
    let p_query_sort = sort;

    let uri_str = format!(
        "{}/admin/v1/projects/{projectId}/apps:search",
        configuration.base_path,
        projectId = crate::generated_admin::apis::urlencode(p_path_project_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_query {
        req_builder = req_builder.query(&[("query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("key", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::SearchApps200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SearchApps200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchAppsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Searches for apps within a project using full-text search. Use this method for complex queries that exceed URL length limits.  Searchable fields: - app_id: The unique app identifier - display_name: Human-readable display name - platform: Target platform (IOS, ANDROID, MACOS, WINDOWS, LINUX, WEB) - state: App state (ACTIVE, DELETED) - created_at: Timestamp when created - updated_at: Timestamp when last updated  Example queries: - \"my_app\" - Search all fields - \"display_name:Production*\" - Apps with display name starting with \"Production\" - \"platform:IOS\" - iOS apps only
pub async fn search_apps_post(
    configuration: &configuration::Configuration,
    project_id: &str,
    search_apps_post_request: models::SearchAppsPostRequest,
) -> Result<models::SearchApps200Response, Error<SearchAppsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_body_search_apps_post_request = search_apps_post_request;

    let uri_str = format!(
        "{}/admin/v1/projects/{projectId}/apps:search",
        configuration.base_path,
        projectId = crate::generated_admin::apis::urlencode(p_path_project_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("key", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_search_apps_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::SearchApps200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SearchApps200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchAppsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Restores a soft-deleted app. Only works for apps in DELETED state within the 30-day grace period. The app will be restored to ACTIVE state.
pub async fn undelete_app(
    configuration: &configuration::Configuration,
    project_id: &str,
    app_id: &str,
) -> Result<models::UndeleteApp200Response, Error<UndeleteAppError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_path_app_id = app_id;

    let uri_str = format!(
        "{}/admin/v1/projects/{projectId}/apps/{appId}:undelete",
        configuration.base_path,
        projectId = crate::generated_admin::apis::urlencode(p_path_project_id),
        appId = crate::generated_admin::apis::urlencode(p_path_app_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("key", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UndeleteApp200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::UndeleteApp200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UndeleteAppError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Updates an existing app. Updates the app's display name or platform-specific configuration.
pub async fn update_app(
    configuration: &configuration::Configuration,
    project_id: &str,
    app_id: &str,
    update_app_request: models::UpdateAppRequest,
) -> Result<models::UpdateApp200Response, Error<UpdateAppError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_path_app_id = app_id;
    let p_body_update_app_request = update_app_request;

    let uri_str = format!(
        "{}/admin/v1/projects/{projectId}/apps/{appId}",
        configuration.base_path,
        projectId = crate::generated_admin::apis::urlencode(p_path_project_id),
        appId = crate::generated_admin::apis::urlencode(p_path_app_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("key", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_update_app_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UpdateApp200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::UpdateApp200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateAppError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
